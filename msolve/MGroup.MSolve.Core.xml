<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MGroup.MSolve.Core</name>
    </assembly>
    <members>
        <member name="T:MGroup.MSolve.AnalysisWorkflow.GenericAnalyzerState">
            <summary>
            A generic state object for constitutive law state variables
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.AnalysisWorkflow.Transient.IInitialConditionSet`1.EnumerateNodalInitialConditions(System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.IElementType})" -->
        <member name="T:MGroup.MSolve.AnalysisWorkflow.Logging.ILogFactory">
            <summary>
            Used by the analyzers to create the logs.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.AnalysisWorkflow.Providers.INonTransientAnalysisProvider.GetMatrix">
            <summary>
            Creates the submatrix that corresponds to the free freedom degrees of a subdomain. If A is the matrix corresponding
            to all dofs, f denotes free dofs and c denotes constrained dofs then A = [ Aff Acf^T; Acf Acc ]. This method
            builds and creates only Aff.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Constitutive.GenericConstitutiveLawState">
            <summary>
            A generic state object for constitutive law state variables
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Constitutive.IConstitutiveLaw">
            <summary>
            Interface for constitutive laws to be adhered to, for spatial discretization (e.g.: FEM) 
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Constitutive.IConstitutiveLawWithGenericState">
            <summary>
            Interface for constitutive laws to be adhered to, for spatial discretization (e.g.: FEM) that uses the GenericConstitutiveLawState object for holding its state
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Constitutive.ITransientConstitutiveLaw">
            <summary>
            Interface for constitutive laws to be adhered to, for spatial discretization (e.g.: FEM) 
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.CollectionExtensions.FindFirstIndex``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>
            Searches for the specified object and returns the zero-based index of the first occurrence within the entire list.
            If none is found, -1 is returned.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="value">The object to search for.</param>
            <remarks>
            The list is searched forward starting at the first element and ending at the last element. This method determines 
            equality using <see cref="M:System.Object.Equals(System.Object)"/>. This method performs a linear search; therefore, this 
            method is an O(n) operation, where n is Count.
            </remarks>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.CollectionExtensions.FindFirstIndex``1(System.Collections.Generic.IReadOnlyList{``0},``0,System.Func{``0,System.Boolean})">
            <summary>
            Searches for an element of the list that satisfies a given condition and returns the zero-based index of the first 
            occurrence within the entire list. If none is found, -1 is returned.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="value">The object to search for.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <remarks>
            The list is searched forward starting at the first element and ending at the last element. This method performs a 
            linear search; therefore, this method is an O(n) operation, where n is Count.
            </remarks>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.CollectionExtensions.FindLastIndex``1(System.Collections.Generic.IReadOnlyList{``0},``0)">
            <summary>
            Searches for the specified object and returns the zero-based index of the last occurrence within the entire list.
            If none is found, -1 is returned.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="value">The object to search for.</param>
            <remarks>
            The list is searched backward starting at the last element and ending at the first element. This method determines 
            equality using <see cref="M:System.Object.Equals(System.Object)"/>. This method performs a linear search; therefore, this 
            method is an O(n) operation, where n is Count.
            </remarks>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.CollectionExtensions.FindLastIndex``1(System.Collections.Generic.IReadOnlyList{``0},``0,System.Func{``0,System.Boolean})">
            <summary>
            Searches for an element of the list that satisfies a given condition and returns the zero-based index of the last 
            occurrence within the entire list. If none is found, -1 is returned.
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="list"></param>
            <param name="value">The object to search for.</param>
            <param name="predicate">A function to test each element for a condition.</param>
            <remarks>
            The list is searched backward starting at the last element and ending at the first element. This method performs a 
            linear search; therefore, this method is an O(n) operation, where n is Count.
            </remarks>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.InvalidSolverException">
            <summary>
            The exception that is thrown when the chosen solver does not match the discrete model. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.InvalidSolverException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.InvalidSolverException"/> class.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.InvalidSolverException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.InvalidSolverException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.InvalidSolverException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.InvalidSolverException"/> class with a specified error message 
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">
            The exception that is the cause of the current exception. If the innerException parameter is nota null reference, 
            the current exception is raised in a catch block that handles the inner exception. 
            </param>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.ITable`3">
            <summary>
            Interface for table data structures, which associate ordered pairs (row, column) with values. Contrary to matrices, not 
            all (row, column) pairs of a table need to be associated with values.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TRow"></typeparam>
            <typeparam name="TColumn"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:MGroup.MSolve.DataStructures.ITable`3.NumEntries">
            <summary>
            The total number of entries in this table. 
            </summary>
        </member>
        <member name="P:MGroup.MSolve.DataStructures.ITable`3.Item(`0,`1)">
            <summary>
            The value associated with the pair (<paramref name="row"/>, <paramref name="col"/>).
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the pair (<paramref name="row"/>, <paramref name="col"/>) has not 
                been associated with a value.</exception>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable`3.Contains(`0,`1)">
            <summary>
            True if the pair (<paramref name="row"/>, <paramref name="col"/>) has already been associated with a value.
            </summary>
            <param name="row"></param>
            <param name="col"></param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable`3.GetColumnsOfRow(`0)">
            <summary>
            Returns a collection of the <see cref="!:TColumn"/> indices of all (<paramref name="row"/>, <see cref="!:TColumn"/>) 
            pairs in this object.
            </summary>
            <param name="row"></param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable`3.GetRows">
            <summary>
            Returns a collection of all the <see cref="!:TRow"/> indices in this object.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable`3.GetValuesOfRow(`0)">
            <summary>
            Returns a collection of all <see cref="!:TValue"/> values associated with the (<paramref name="row"/>, 
            <see cref="!:TColumn"/>) pairs in this object.
            </summary>
            <param name="row"></param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable`3.TryGetValue(`0,`1,`2@)">
            <summary>
            Returns true if the pair (<paramref name="row"/>, <paramref name="col"/>) has been associated with a value, which is  
            also returned as an output parameter <paramref name="value"/>. Otherwise returns false instead of throwing any 
            exception.
            </summary>
            <param name="row"></param>
            <param name="col"></param>
            <param name="value"></param>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.ITable3D`4">
            <summary>
            Interface for table data structures, which associate ordered triplets (key1, key2, key3) with values. Not all triplets
            of a table need to be associated with values.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TKey1"></typeparam>
            <typeparam name="TKey2"></typeparam>
            <typeparam name="TKey3"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:MGroup.MSolve.DataStructures.ITable3D`4.EntryCount">
            <summary>
            The total number of entries in this table. 
            </summary>
        </member>
        <member name="P:MGroup.MSolve.DataStructures.ITable3D`4.Item(`0,`1,`2)">
            <summary>
            The value associated with the triplet (<paramref name="key1"/>, <paramref name="key2"/>, <paramref name="key3"/>).
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="key3"></param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">Thrown if the triplet 
                (<paramref name="row"/>, <paramref name="key2"/>, <paramref name="key3"/>) has not been associated with a
                value.</exception>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable3D`4.Contains(`0,`1,`2)">
            <summary>
            True if the triplet (<paramref name="key1"/>, <paramref name="key2"/>, <paramref name="key3"/>) has already been 
            associated with a value.
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="key3"></param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.ITable3D`4.TryGetValue(`0,`1,`2,`3@)">
            <summary>
            Returns true if the triplet (<paramref name="key1"/>, <paramref name="key2"/>, <paramref name="key3"/>) has been 
            associated with a value, which is also returned as an output parameter <paramref name="value"/>. Otherwise returns 
            false instead of throwing any exception.
            </summary>
            <param name="key1"></param>
            <param name="key2"></param>
            <param name="key3"></param>
            <param name="value"></param>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException">
            <summary>
            The exception that is thrown when an iterative solver or a domain decomposition solver that uses iterative methods 
            cannot converge for a given problem and set of parameters. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException"/> class.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException"/> class with a specified 
            error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MGroup.MSolve.DataStructures.IterativeSolverNotConvergedException"/> class with a specified 
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="inner">
            The exception that is the cause of the current exception. If the innerException parameter is not a null reference, 
            the current exception is raised in a catch block that handles the inner exception. 
            </param>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.Table`3">
            <summary>
            Basic table data structure, which associates ordered pairs (row, column) with values. Contrary to matrices, not 
            all (row, column) pairs of a table need to be associated with values.
            Authors: Serafeim Bakalakos, George Stavroulakis
            </summary>
            <typeparam name="TRow"></typeparam>
            <typeparam name="TColumn"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.Table`3.Find(System.Predicate{`2})">
            <summary>
            Finds and returns the an entry for which <typeparamref name="TValue"/>> satisfies <paramref name="predicate"/>.
            If none is found, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown.
            </summary>
            <param name="predicate"></param>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.Table`3.TryAdd(`0,`1,`2)">
            <summary>
            Adds the specified (<paramref name="row"/>, <paramref name="col"/>, <paramref name="value"/>) entry to the table. 
            Returns true, if the insertion was successful, or false, if the table already contained the specified entry.
            </summary>
            <param name="row">The </param>
            <param name="col"></param>
            <param name="value"></param>
        </member>
        <member name="T:MGroup.MSolve.DataStructures.Table3D`4">
            <summary>
            Interface for table data structures, which associate ordered pairs (row, column) with values. Contrary to matrices, not 
            all (row, column) pairs of a table need to be associated with values.
            Authors: Serafeim Bakalakos, George Stavroulakis
            </summary>
            <typeparam name="TRow"></typeparam>
            <typeparam name="TColumn"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.Tensor2D.MultiplyColon(MGroup.MSolve.DataStructures.Tensor2D)">
            <summary>
            Colon multiplication of tensors A, B is defined as: A:B = Aij * Bij
            </summary>
            <param name="tensor"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.DataStructures.Tensor2D.Rotate(System.Double)">
            <summary>
            Rotates the tensor counter clockwise.
            </summary>
            <param name="angle">The counter-clockwise angle that the current tensor is rotated. Should belong to 
                (-π, π] for uniformity, although that isn't checked.</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Discretization.BoundaryConditions.IBoundaryConditionSet`1.EnumerateNodalBoundaryConditions(System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.IElementType})" -->
        <member name="T:MGroup.MSolve.Discretization.CellType">
            <summary>
            Defines the shape of a cell only. Since there are no dependencies, it can also be used to map corresponding cell/element 
            types from one module to another.
            Authors: Serafeim Bakalakos, Dimitris Tsapetis
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Dofs.DofTable">
            <summary>
            A <see cref="T:MGroup.MSolve.DataStructures.ITable`3"/> that associates the freedom degrees of nodes with their ordinal number.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TDof">A freedom degree type.</typeparam>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.DofTable.GetSubtableForNodes(System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            
            </summary>
            <param name="nodes">If one of these is not contained in the original table, it will be ignored.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.DofTable.Reorder(System.Collections.Generic.IReadOnlyList{System.Int32},System.Boolean)">
            <summary>
            Renumbers the dof indices according to the given permutation vector and direction. 
            If (<paramref name="oldToNew"/> == true), then newIndex[dof] = <paramref name="permutation"/>[oldIndex[dof]].
            Else oldIndex[dof] = <paramref name="permutation"/>[nwIndex[dof]]
            </summary>
            <param name="permutation">The permutation vector.</param>
            <param name="oldToNew">The direction it should be applied to.</param>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Dofs.IDofType">
            <summary>
            Tagging interface for degrees of freedom. Concrete implementations must be immutable.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetDofTypesForMatrixAssembly(MGroup.MSolve.Discretization.IElementType)">
            <summary>
            These are the dofs of the nodes returned by <see cref="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetNodesForMatrixAssembly(MGroup.MSolve.Discretization.IElementType)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetDofTypesForDofEnumeration(MGroup.MSolve.Discretization.IElementType)">
            <summary>
            The returned outer list will include nested lists for all <see cref="!:IElement.Nodes"/>. When using embedding, the
            nested lists that correspond to embedded nodes, will be empty.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetNodesForMatrixAssembly(MGroup.MSolve.Discretization.IElementType)">
            <summary>
            When using embedding, these are the nodes of the superelement: nodes that have not been embedded and (right now all) 
            nodes of the host element. 
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetTransformedDisplacementsVector(System.Double[])">
            <summary>
            Returns element local displacements.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Dofs.IElementDofEnumerator.GetTransformedForcesVector(System.Double[])">
            <summary>
            Returns super-element forces.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Entities.Node">
            <summary>
            Vertex of a finite element in a 3-dimensional space. It can also represent points in 1-dimensional or 2-dimension 
            spaces. Immutable.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Entities.Node.#ctor(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Discretization.Entities.Node"/>.
            </summary>
            <param name="id">
            A unique identifier <see cref="P:MGroup.MSolve.Discretization.Entities.Node.ID"/> to differentiate this instance of <see cref="!:Node1D"/> from the rest. 
            Constraints: <see cref="P:MGroup.MSolve.Discretization.Entities.Node.ID"/> &gt;= 0.
            </param>
            <param name="x">The coordinate of the point along the single axis X.</param>
            <param name="y">The coordinate of the point along the single axis Y.</param>
            <param name="z">The coordinate of the point along the single axis Z.</param>
        </member>
        <member name="P:MGroup.MSolve.Discretization.Entities.Node.ID">
            <summary>
            A unique identifier <see cref="P:MGroup.MSolve.Discretization.Entities.Node.ID"/> to differentiate this instance of <see cref="T:MGroup.MSolve.Discretization.Entities.Node"/> from the rest. 
            Constraints: <see cref="P:MGroup.MSolve.Discretization.Entities.Node.ID"/> &gt;= 0.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.IDiscretePoint">
            <summary>
            Tagging interface for discrete point where interesting quantities are known or computed. E.g. in FEM such points are 
            called nodes.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.BidirectionalMesh2D`2">
            <summary>
            Also keeps track of which elements are connected to each node
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.CellConnectivity`1">
            <summary>
            Data Transfer Object that packs the <see cref="P:MGroup.MSolve.Discretization.Meshes.Generation.CellConnectivity`1.CellType"/> with the vertices of a cell. Since there are no 
            dependencies, it can be used to transfer cell/element geometry data from one module to another.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Discretization.Meshes.Generation.Custom.RectilinearMeshGenerator2D`1.PartitionSegment(System.Double,System.Double,System.Double,System.Double)" -->
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.Custom.UniformMeshGenerator2D`1">
            <summary>
            Creates 2D meshes based on uniform rectilinear grids: the distance between two consecutive vertices for the same axis is 
            constant. This distance may be different for each axis though. For now the cells are quadrilateral with 4 vertices 
            (rectangles in particular).
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.Custom.UniformMeshGenerator2D`1.CreateMesh(MGroup.MSolve.Discretization.Meshes.Generation.CreateNode{`0})">
            <summary>
            Generates a uniform mesh with the dimensions and density defined in the constructor.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.Custom.UniformMeshGenerator3D`1">
            <summary>
            Creates 3D meshes based on uniform rectilinear grids: the distance between two consecutive vertices for the same axis is 
            constant. This distance may be different for each axis though. For now the cells are hexahedral with 8 vertices. 
            (bricks in particular).
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.Custom.UniformMeshGenerator3D`1.CreateMesh(MGroup.MSolve.Discretization.Meshes.Generation.CreateNode{`0})">
            <summary>
            Generates a uniform mesh with the dimensions and density defined in the constructor.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshCellFactory`1">
            <summary>
            Converts cell types and the order of their vertices from GMSH to MSolve.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshCellFactory`1.TryCreateCell(System.Int32,System.Int32[],MGroup.MSolve.Discretization.Meshes.Generation.CellConnectivity{`0}@)">
            <summary>
            Returns true and a <see cref="!:CellConnectivity"/> if the <paramref name="cellCode"/> corresponds to a valid 
            MSolve <see cref="T:MGroup.MSolve.Discretization.CellType"/>. 
            Otherwise returns false and null.
            </summary>
            <param name="cellCode"></param>
            <param name="vertexIDs"> These must be 0-based</param>
            <param name="cell"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshCellFactory`1.FixVerticesOrder(`0[])">
            <summary>
            If the order is clockwise, it is reversed. Not sure if it sufficient or required for second order elements.
            </summary>
            <param name="cellVertices"></param>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshReader`1">
            <summary>
            Creates meshes by reading GMSH output files (.msh). Unrecognized GMSH cell types will be ignored along with any 1D cells
            in the .msh file, therefore some care is needed.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshReader`1.#ctor(System.String)">
            <summary>
            Opens the .msh file but doesn't read it.
            </summary>
            <param name="mshFilePath">
            The absolute path of the .msh file where GMSH has written the mesh data. The .msh file will not be modified.
            </param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Generation.GMSH.GmshReader`1.CreateMesh(MGroup.MSolve.Discretization.Meshes.Generation.CreateNode{`0})">
            <summary>
            Reads the whole .msh file and converts it to MSolve mesh data.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.IMeshGenerator`1">
            <summary>
            Creates 2D and 3D meshes for use in FEM or similar methods.
            Authors: Serafeim Bakalakos
            </summary>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Generation.CreateNode`1">
            <summary>
            Initializes a new instance of some class that implements <see cref="T:MGroup.MSolve.Discretization.Entities.INode"/>.
            </summary>
            <param name="id">The unique identifier of the node.</param>
            <param name="x">The x coordinate of the node.</param>
            <param name="y">The y coordinate of the node. Leave it 0.0 for 1D problems.</param>
            <param name="z">The z coordinate of the node. Leave it 0.0 for 1D, 2D problems.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.IMesh2D`2.FindElementsContainingPoint(MGroup.MSolve.Geometry.Coordinates.CartesianPoint,`1)">
            <summary>
            Find the elements that contain the provided point. The following cases are possible:
            Case 1) The point is inside 1 element. Only that element will be returned. 
            Case 2) The point is on the edge of 2 elements. Both elements will be returned.
            Case 3) The point coincides with a node of 3 or more elements. All these elements will be returned.
            Case 4) The point is outside the mesh. The returned collection will be empty.
            </summary>
            <param name="point">The point to search.</param>
            <param name="startingElement">An element around which to start the search. If no such element is provided 
                the search will probably take longer, usually O(elementsCount).</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.IMesh2D`2.FindElementsIntersectedByCircle(MGroup.MSolve.Geometry.Shapes.Circle2D,`1)">
            <summary>
            Find the elements that are intersected by the provided circle. The following cases are possible:
            Case 1) The circle intersects the edges of some elements and at least 1 intesection point per element is 
                not a node. These elements will be returned.
            Case 2) All elements are either completely outside or completely inside the circle (they might touch at 
                nodal points though). A 3rd option is that the circle is small enough to be completely inside an 
                element. The returned collection will be empty.
            </summary>
            <param name="circle">The circle to consider.</param>
            <param name="startingElement">An element around which to start the search. If no such element is provided 
                the search will probably take longer, usually O(elementsCount).</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Discretization.Meshes.IMesh2D`2.FindElementsInsideCircle(MGroup.MSolve.Geometry.Shapes.Circle2D,`1)" -->
        <member name="M:MGroup.MSolve.Discretization.Meshes.IMesh2D`2.FindNodesInsideCircle(MGroup.MSolve.Geometry.Shapes.Circle2D,System.Boolean,`1)">
            <summary>
            Find the nodes of the mesh which are inside (and optionally exactly on) the provided circle. If there are
            none, the returned collection will be empty.
            </summary>
            <param name="circle"></param>
            <param name="findBoundaryNodes">True if nodes, whose distance to the circle's center is exactly equal to 
                the radius, are to be returned as well.</param>
            <param name="startingElement">An element around which to start the search. If no such element is provided 
                the search will probably take longer, usually O(nodesCount).</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Manifolds.TriangleMesh3D.CreateForRectangle(System.Double[],System.Double[],System.Double[],System.Int32,System.Int32)">
            <summary>
            The triangles will have the same normal as the rectangle, which is n = ABxAC / |ABxAC|.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkCell">
            <summary>
            Cell used to represent VTK grids.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkFileWriter">
            <summary>
            Writes meshes, scalars, vectors and tensor fields to .vtk output files. Then these files can be opened in Paraview.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkFileWriter.WriteMesh(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkPoint},System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkCell})">
            <summary>
            
            </summary>
            <param name="points">They must be sorted on their IDs, which start from 0 and are contiguous.</param>
            <param name="cells"></param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkFileWriter.WriteScalarField(System.String,System.Double[])">
            <summary>
            
            </summary>
            <param name="fieldName"></param>
            <param name="pointValues">They must be in the exact same order as the nodes.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkFileWriter.WriteTensor2DField(System.String,System.Collections.Generic.IReadOnlyList{System.Double[]})">
            <summary>
            Tensor components are written as independent scalar fields, as I haven't found any advantage in using tensor datasets 
            in Paraview. By exporting each one as a different scalar field, better naming can be enforces, instead of 0, 1, etc. 
            indexing for each tensor component.
            </summary>
            <param name="fieldName">Each component will be prefixed by it. E.g. fieldName = "S": S_11, S_22, S_12.</param>
            <param name="pointValues">Each row correspond to a different node. They must be in the exact same order as the nodes.
                Columns 0, 1 and 2 are the tensor entries T11, T22, T12 respectively.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkFileWriter.WriteVectorField(System.String,System.Collections.Generic.IReadOnlyList{System.Double[]})">
            <summary>
            </summary>
            <param name="fieldName"></param>
            <param name="pointVectors">They must be in the exact same order as the nodes.</param>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Output.VTK.VtkPoint">
            <summary>
            Vertex used to represent VTK grids.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.SimpleMesh2D`2">
            <summary>
            Unoptimized. Uses little storage. All search operations take linear time: O(nodesCount) and O(elementsCount).
            </summary>
            <typeparam name="TNode"></typeparam>
            <typeparam name="TElement"></typeparam>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Structured.ICartesianMesh">
            <summary>
            Special case of structured mesh, where elements are quadrilaterals in 2D or hexahedrals in 3D.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.IStructuredMesh.EnumerateNodes">
            <summary>
            Enumerates the global IDs and coordinates of the nodes. The nodes are returned in increasing order of their id.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.IStructuredMesh.EnumerateElements">
            <summary>
            For each element returns its global ID and the global IDs of its nodes. The elements are returned in increasing order
            of their id.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.#ctor(System.Double[],System.Double[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="minCoordinates"></param>
            <param name="maxCoordinates"></param>
            <param name="numElements">Array with 3 positive integers.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.SetElementNodeOrderClockwise">
            <summary>
            Applies a clockwise order of nodes in each Quad4 element of the mesh:
            node0 = (-1, +1), node1 = (+1, +1), node2 = (+1, -1), node3 = (-1, -1), 
            where the +-1 coordinates correspond to the local coordinate system of the element.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.SetElementNodeOrderCounterClockwise">
            <summary>
            Reapplies the default counter-clockwise order of nodes in each Quad4 element of the mesh:
            node0 = (-1, -1), node1 = (+1, -1), node2 = (+1, +1), node3 = (-1, +1), 
            where the +-1 coordinates correspond to the local coordinate system of the element.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.SetElementNodeOrderPermutation(System.Int32[])">
            <summary>
            Configures the order of nodes in each Quad4 element of the mesh. By default this order is: 
            node0 = (-1, -1), node1 = (+1, -1), node2 = (+1, +1), node3 = (-1, +1), 
            where the +-1 coordinates correspond to the  local coordinate system of the element. 
            To change this order, <paramref name="permutation"/> must be a permutation array such that: 
            finalOrder[<paramref name="permutation"/>[i]] = defaultOrder[i], i = 0,1,...3 .
            </summary>
            <param name="permutation">
            The permutation of element nodes: finalOrder[<paramref name="permutation"/>[i]] = defaultOrder[i], i = 0,1,...3.
            </param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.SetMajorAxis(System.Int32)">
            <summary>
            The node IDs will be ordered such that they are contiguous along dimension <paramref name="axis"/>. Calling this
            method overrides the default node order: nodes are contiguous in the dimension with mininum number of nodes.
            </summary>
            <param name="axis">The axis along which node ids will be contiguous. 0 for x or 1 for y.</param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh2D.Builder.SetMajorAxisDefault">
            <summary>
            Reapplies the default order of node ids: nodes are contiguous in the dimension with mininum number of nodes.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.#ctor(System.Double[],System.Double[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="minCoordinates"></param>
            <param name="maxCoordinates"></param>
            <param name="numElements">Array with 3 positive integers.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.SetElementNodeOrderBathe">
            <summary>
            Applies Bathe's order of nodes in each Hexa8 element of the mesh:
            node0 = (+1, +1, +1), node1 = (-1, +1, +1), node2 = (-1, -1, +1), node3 = (+1, -1, +1), 
            node4 = (+1, +1, -1), node5 = (-1, +1, -1), node6 = (-1, -1, -1), node7 = (+1, -1, -1) 
            where the +-1 coordinates correspond to the local coordinate system of the element.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.SetElementNodeOrderDefault">
            <summary>
            Reapplies the default order of nodes in each Hexa8 element of the mesh:
            node0 = (-1, -1, -1), node1 = (+1, -1, -1), node2 = (+1, +1, -1), node3 = (-1, +1, -1), 
            node4 = (-1, -1, +1), node5 = (+1, -1, +1), node6 = (+1, +1, +1), node7 = (-1, +1, +1)
            where the +-1 coordinates correspond to the local coordinate system of the element.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.SetElementNodeOrderPermutation(System.Int32[])">
            <summary>
            Configures the order of nodes in each Quad4 element of the mesh. By default this order is: 
            node0 = (-1, -1, -1), node1 = (+1, -1, -1), node2 = (+1, +1, -1), node3 = (-1, +1, -1), 
            node4 = (-1, -1, +1), node5 = (+1, -1, +1), node6 = (+1, +1, +1), node7 = (-1, +1, +1)
            where the +-1 coordinates correspond to the  local coordinate system of the element. 
            To change this order, <paramref name="permutation"/> must be a permutation array such that: 
            finalOrder[<paramref name="permutation"/>[i]] = defaultOrder[i], i = 0,1,...3 .
            </summary>
            <param name="permutation">
            The permutation of element nodes: finalOrder[<paramref name="permutation"/>[i]] = defaultOrder[i], i = 0,1,...3.
            </param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.SetMajorMinorAxis(System.Int32,System.Int32)">
            <summary>
            The node ids will be ordered such that they are contiguous along dimension <paramref name="majorAxis"/>, while they  
            will have the maximum id difference along dimension <paramref name="minorAxis"/>. 
            Calling this method overrides the default node order: nodes are contiguous in the dimension with mininum
            number of nodes and have the maximum id difference in the dimension with the maximum number of nodes.
            </summary>
            <param name="majorAxis">
            The axis along which node ids will be contiguous. 0 for x, 1 for y or 2 for z. 
            Must be different from <paramref name="minorAxis"/>.
            </param>
            <param name="minorAxis">
            The axis along which node ids will have the maximum distance (compared to other axes). 
            0 for x, 1 for y or 2 for z. Must be different from <paramref name="majorAxis"/>.
            </param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformCartesianMesh3D.Builder.SetMajorMinorAxisDefault">
            <summary>
            Reapplies the default order of node ids: nodes are contiguous in the dimension with mininum number of nodes
            and have the maximum id difference in the dimension with the maximum number of nodes.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D">
            <summary>
            Structured mesh with uniform distances between points on a cartesian grid. The elements are Tri3 (simplices) generated
            by dividing each Quad4 cell of an equivalent cartesian mesh into 2 subtriangles. The element indices are thus int[3], 
            where the first 2 entries are the index of the enclosing Quad4 of an equivalent cartesian mesh and the third entry is 
            0 or 1 to denote one of the 2 subtriangles of said Quad4.
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D.elementNodeIdxOffsets">
            <summary>
            Given the index (i,j) of the first node of a Quad4 with coordinates=(-1,-1), this list contains, for each subtriangle 
            of the Quad, the index offsets relative to (i,j) of the nodes of the subtriangle. The offset of node (i,j) is (0,0),
            the offset of (i+1, j) is (1,0) and so forth.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D.GetElementID(System.Int32[])">
            <summary>
            Example: Suppose a 3x4 mesh where there are 4 nodes with indices n7(1,2), n8(2,2), n10(1,3), n11(2,3) and 2 triangles 
            t10(n7,n8,n10), t11(n11,n10,n8). 
            t10 corresponds to <paramref name="elementIdx"/> = (1,2,0). 
            t11 corresponds to <paramref name="elementIdx"/> = (1,2,1). 
            </summary>
            <param name="elementIdx">The index of the element. An integer array with length = 3.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D.Builder.#ctor(System.Double[],System.Double[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="minCoordinates"></param>
            <param name="maxCoordinates"></param>
            <param name="numElements">Array with 3 positive integers.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D.Builder.SetMajorAxis(System.Int32)">
            <summary>
            The node IDs will be ordered such that they are contiguous along dimension <paramref name="axis"/>. Calling this
            method overrides the default node order: nodes are contiguous in the dimension with mininum number of nodes.
            </summary>
            <param name="axis">The axis along which node ids will be contiguous. 0 for x or 1 for y.</param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh2D.Builder.SetMajorAxisDefault">
            <summary>
            Reapplies the default order of node ids: nodes are contiguous in the dimension with mininum number of nodes.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh3D">
            <summary>
            Structured mesh with uniform distances between points on a cartesian grid. The elements are Tet4 (simplices) generated
            by dividing each Hexa8 cell of an equivalent cartesian mesh into 4 subtetrahedra. The element indices are thus int[4], 
            where the first 3 entries are the index of the enclosing Hexa8 of an equivalent cartesian mesh and the third entry is 
            0, 1, 2 or 3 to denote one of the 4 subtetrahedra of said Hexa8.
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh3D.elementNodeIdxOffsets">
            <summary>
            Given the index (i,j,k) of the first node of a Hexa with coordinates=(-1,-1,-1), this list contains, for each 
            subtetrahedron of the Hexa8, the index offsets relative to (i,j,k) of the nodes of the subtetrahedron. The offset of 
            node (i,j,k) is (0,0,0), the offset of (i+1, j, k+1) is (1,0,1) and so forth.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh3D.Builder.#ctor(System.Double[],System.Double[],System.Int32[])">
            <summary>
            
            </summary>
            <param name="minCoordinates"></param>
            <param name="maxCoordinates"></param>
            <param name="numNodes">Array with 3 positive integers.</param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh3D.Builder.SetMajorMinorAxis(System.Int32,System.Int32)">
            <summary>
            The node ids will be ordered such that they are contiguous along dimension <paramref name="majorAxis"/>, while they  
            will have the maximum id difference along dimension <paramref name="minorAxis"/>. 
            Calling this method overrides the default node order: nodes are contiguous in the dimension with mininum
            number of nodes and have the maximum id difference in the dimension with the maximum number of nodes.
            </summary>
            <param name="majorAxis">
            The axis along which node ids will be contiguous. 0 for x, 1 for y or 2 for z. 
            Must be different from <paramref name="minorAxis"/>.
            </param>
            <param name="minorAxis">
            The axis along which node ids will have the maximum distance (compared to other axes). 
            0 for x, 1 for y or 2 for z. Must be different from <paramref name="majorAxis"/>.
            </param>
            <returns>This object for chaining.</returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Structured.UniformSimplicialMesh3D.Builder.SetMajorMinorAxisDefault">
            <summary>
            Reapplies the default order of node ids: nodes are contiguous in the dimension with mininum number of nodes
            and have the maximum id difference in the dimension with the maximum number of nodes.
            </summary>
            <returns>This object for chaining.</returns>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshCellFactory">
            <summary>
            Converts cell types and the order of their vertices from GMSH to MSolve.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshCellFactory.FindElementNodes(MGroup.MSolve.Discretization.CellType,System.Int32[])">
            <summary>
            Returns true and a <see cref="!:CellConnectivity"/> if the <paramref name="cellCode"/> corresponds to a valid 
            MSolve <see cref="T:MGroup.MSolve.Discretization.CellType"/>. 
            Otherwise returns false and null.
            </summary>
            <param name="cellCode"></param>
            <param name="nodeIDs"> These must be 0-based</param>
            <param name="cell"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshCellFactory.FixNodeOrder(System.Collections.Generic.IList{System.Double[]})">
            <summary>
            If the order is clockwise, it is reversed.
            </summary>
            <param name="cellVertices"></param>
        </member>
        <member name="T:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshReader">
            <summary>
            Creates meshes by reading GMSH output files (.msh). Unrecognized GMSH cell types will be ignored along with any 1D cells
            in the .msh file, therefore some care is needed.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshReader.#ctor(System.Int32,System.String)">
            <summary>
            Opens the .msh file but doesn't read it.
            </summary>
            <param name="mshFilePath">
            The absolute path of the .msh file where GMSH has written the mesh data. The .msh file will not be modified.
            </param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshReader.CreateMesh">
            <summary>
            Reads the whole .msh file and converts it to MSolve mesh data.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.Gmsh.GmshReader.ReadElements(MGroup.MSolve.Discretization.Meshes.Unstructured.UnstructuredMesh)">
            <summary>
            It must be called after vertices are read.
            </summary>
            <param name="vertices"></param>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.IUnstructuredMesh.EnumerateNodes">
            <summary>
            Enumerates the global IDs and coordinates of the nodes. The nodes are returned in increasing order of their id.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Discretization.Meshes.Unstructured.IUnstructuredMesh.EnumerateElements">
            <summary>
            For each element returns its global ID, cell type and the global IDs of its nodes. The elements are returned in 
            increasing order of their id.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Coordinates.CartesianPoint">
            <summary>
            Point in a 3-dimensional cartesian coordinate system. It can also represent points in 1-dimensional or 2-dimension 
            spaces, but not all coordinates will be used. Immutable
            Authors: Serafeim Bakalakos, Dimitris Tsapetis
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Geometry.Coordinates.CartesianPoint"/>
            </summary>
            <param name="x">The coordinate of the point along axis X.</param>
            <param name="y">The coordinate of the point along axis Y.</param>
            <param name="z">The coordinate of the point along axis Z.</param>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.#ctor(System.Double[])">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Geometry.Coordinates.CartesianPoint"/>
            </summary>
            <param name="coordinates">Vector with the coordinates of the point. Length = 3.</param>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.Coordinates">
            <summary>
            Vector with the coordinates of the point. Length = 3.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.X">
            <summary>
            The coordinate of the point along axis X.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.Y">
            <summary>
            The coordinate of the point along axis Y.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.Z">
            <summary>
            The coordinate of the point along axis Z.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.CartesianPoint.CalculateDistanceFrom(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)">
            <summary>
            Calculates the Euclidian distance between a <see cref="T:MGroup.MSolve.Geometry.Coordinates.CartesianPoint"/> named <paramref name="other"/> and this 
            one. It will be non negative.
            </summary>
            <param name="other">The other <see cref="T:MGroup.MSolve.Geometry.Coordinates.CartesianPoint"/>.</param>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Coordinates.IPoint">
            <summary>
            Point in a 3-dimensional space. It can also represent points in 1-dimensional or 2-dimension spaces, but not all 
            coordinates will be used. Immutable.
            Authors: Serafeim Bakalakos, Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.IPoint.Coordinates">
            <summary>
            Vector with the coordinates of the point. Length = 3.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.IPoint.X1">
            <summary>
            The first coordinate of the point.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.IPoint.X2">
            <summary>
            The second coordinate of the point.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.IPoint.X3">
            <summary>
            The third coordinate of the point.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Coordinates.NaturalPoint">
            <summary>
            Point in a 3-dimensional cartesian coordinate system, which is local to the finite element. It can also represent points 
            in 1-dimensional or 2-dimension spaces, but not all coordinates will be used. Immutable
            Authors: Serafeim Bakalakos, Dimitris Tsapetis
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Geometry.Coordinates.NaturalPoint"/>
            </summary>
            <param name="xi">The coordinate of the point along local axis Xi</param>
            <param name="eta">The coordinate of the point along local axis Eta</param>
            <param name="zeta">The coordinate of the point along local axis Zeta</param>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.#ctor(System.Double[])">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Geometry.Coordinates.NaturalPoint"/>
            </summary>
            <param name="coordinates">Vector with the coordinates of the point. Length = 2.</param>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.Coordinates">
            <summary>
            Vector with the coordinates of the point. Length = 3.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.Xi">
            <summary>
            The coordinate of the point along local axis Xi.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.Eta">
            <summary>
            The coordinate of the point along local axis Eta.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.NaturalPoint.Zeta">
            <summary>
            The coordinate of the point along local axis Zeta.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D">
            <summary>
            Point in a 2-dimensional polar coordinate system. Immutable.
            For more see https://en.wikipedia.org/wiki/Polar_coordinate_system.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D.#ctor(System.Double,System.Double)">
            <summary>
            Instantiates a <see cref="T:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D"/>.
            </summary>
            <param name="r">The radial coordinate of the point.</param>
            <param name="theta">The angular coordinate of the point.</param>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D.Coordinates">
            <summary>
            Vector with the coordinates of the point. Length = 2.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D.R">
            <summary>
            The radial coordinate of the point.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Coordinates.PolarPoint2D.Theta">
            <summary>
            The angular coordinate of the point.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Geometry.MathUtilities.WrapAngle(System.Double)" -->
        <member name="T:MGroup.MSolve.Geometry.Quaternion">
             Class for quaternions to represent finite rotations.
            
             @author Theofilos Manitaras
        </member>
        <member name="M:MGroup.MSolve.Geometry.Quaternion.CreateFromIndividualParts(System.Double,System.Double[])">
             Creates a quaternion from individual scalar and vector parts.
            
             @param scalarPart
                        The scalar part
             @param vectorPart
                        The vector part
             @return The new quaternion
        </member>
        <member name="M:MGroup.MSolve.Geometry.Quaternion.OfZeroAngle">
             Creates a new quaternion of zero angle.
            
             @return The new quaternion
        </member>
        <member name="M:MGroup.MSolve.Geometry.Quaternion.ApplyIncrementalRotation(System.Double[])">
             Rotates the quaternion by an incremental rotation given in vector form.
            
             @param incrementalRotation
                        The incremental rotation
        </member>
        <member name="M:MGroup.MSolve.Geometry.Quaternion.ApplyIncrementalRotationToNew(System.Double[])">
             Rotates the quaternion to a new quaternion by an incremental rotation given in vector form.
            
             @param incrementalRotation
                        The incremental rotation
             @return The rotated quaternion
        </member>
        <member name="M:MGroup.MSolve.Geometry.RotationMatrix.CalculateFromOrthonormalVectors(System.Double[],System.Double[],System.Double[])">
             Calculates a rotation matrix from three orthonormal vectors.
            
             @param vectorX
                        The vector along the X axis
             @param vectorY
                        The vector along the Y axis
             @param vectorZ
                        The vector along the Z axis
             @return The rotation matrix
        </member>
        <member name="M:MGroup.MSolve.Geometry.RotationMatrix.CalculateRotationMatrix(System.Double[],System.Double[])">
             Calculates the rotations matrix given initial and rotated vectors.
            
             @param initialVector
                        The initial vector
             @param rotatedVector
                        The rotated vector
             @return The rotation matrix
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Geometry.Shapes.ConvexPolygon2D.IsPointInsidePolygon(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)" -->
        <member name="M:MGroup.MSolve.Geometry.Shapes.ConvexPolygon2D.IntersectsWithCircle(MGroup.MSolve.Geometry.Shapes.Circle2D)">
            <summary>
            Shortcut method to avoid redundant checks
            </summary>
            <param name="circle"></param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D">
            <summary>
            I would name it Vector, but that means a gazillion of things.
            TODO: I don't see why I need the LineSegment2D inheritance; I override pretty much everything.
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D.cosa">
            <summary>
            a is the counter-clockwise angle from the global x axis to the local x axis
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D.sina">
            <summary>
            a is the counter-clockwise angle from the global x axis to the local x axis
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D.originLocalX">
            <summary>
            The coordinates of the global system's origin in the local system
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D.originLocalY">
            <summary>
            The coordinates of the global system's origin in the local system
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.DirectedSegment2D.normalVector">
            <summary>
            The unit vector that is perpendicular to the segment and faces towards the positive local y axis. 
            It is constant for a linear segment, so caching it avoids recalculations.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Shapes.ICurve2D.NormalVectorThrough(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)">
            <summary>
            Unit length
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Shapes.IOpenCurve2D.TangentAtStart">
            <summary>
            Unit vector. It will coincide with the normal vector if rotated -PI/2.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Geometry.Shapes.IOpenCurve2D.TangentAtEnd">
            <summary>
            Unit vector. It will coincide with the normal vector if rotated PI/2.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Shapes.LineSegment2D.IntersectionWith(MGroup.MSolve.Geometry.Shapes.LineSegment2D,MGroup.MSolve.Geometry.Coordinates.CartesianPoint@)">
            <summary>
            See <see cref="!:http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect"/>
            </summary>
            <param name="segment"></param>
            <param name="intersectionPoint"></param>
            <returns></returns>
        </member>
        <member name="F:MGroup.MSolve.Geometry.Shapes.LineSegment2D.SegmentSegmentPosition.Intersecting">
            <summary>
            This includes the cases where one segments ends on the other.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Shapes.PolyLine2D.EndPointOrientation">
            <summary>
            Counter-clockwise angle from global cartesian x axis to a vector which 1) starts at the end point of the 
            curve, 2) is tangent to the curve and 3) heads outwards from the curve.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Shapes.PolyLine2D.SignedDistanceOf(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)">
            <summary>
            See Fries's slides
            </summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Shapes.PolyLine2D.StartPointOrientation">
            <summary>
            Counter-clockwise angle from global cartesian x axis to a vector which 1) starts at the start point of the 
            curve, 2) is tangent to the curve and 3) heads outwards from the curve.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Triangulation.CreateVertex2D`1">
            <summary>
            Initializes a new instance of some class that implements <see cref="T:MGroup.MSolve.Geometry.Coordinates.IPoint"/>.
            </summary>
            <param name="x">The x coordinate of the node.</param>
            <param name="y">The y coordinate of the node.</param>
        </member>
        <member name="T:MGroup.MSolve.Geometry.Triangulation.Triangle2D`1">
            <summary>
            Wrapper class for 3rd party library triangles. For now I only need 2D triangles in natural system. 
            TODO: make them generic.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Geometry.Triangulation.Triangulator2D`1.#ctor(TriangleNet.Meshing.ITriangulator,MGroup.MSolve.Geometry.Triangulation.CreateVertex2D{`0})">
            <summary>
            
            </summary>
            <param name="mesher">The Triangle.NET algorithm: eg. Dwyer, Incremental</param>
            <param name="createVertex"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MGroup.MSolve.Numerics.Integration.GaussPoint" -->
        <member name="M:MGroup.MSolve.Numerics.Integration.GaussPoint.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new instance of <see cref="T:MGroup.MSolve.Numerics.Integration.GaussPoint"/> for an 1D coordinate system.
            </summary>
            <param name="xi"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Integration.GaussPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of <see cref="T:MGroup.MSolve.Numerics.Integration.GaussPoint"/> for a 2D coordinate system.
            </summary>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Integration.GaussPoint.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new instance of <see cref="T:MGroup.MSolve.Numerics.Integration.GaussPoint"/> for a 3D coordinate system.
            </summary>
            <param name="xi">The coordinate of the point along natural axis Xi.</param>
            <param name="eta">The coordinate of the point along natural axis Eta.</param>
            <param name="zeta">The coordinate of the point along natural axis Zeta.</param>
            <param name="weight">The weight factor of this integration point.</param>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.GaussPoint.Weight">
            <summary>
            The weight factor of this integration point.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre1D">
            <summary>
            Enum class with the 1D Gauss-Legendre integration rules of varying orders. 
            For more see https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss%E2%80%93Legendre_quadrature.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre1D.IntegrationPoints">
            <summary>
            The integrations points are sorted in increasing xi order. This order is strictly defined for each quadrature and 
            cannot change.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre2D">
            <summary>
            Contains the 2D Gauss-Legendre integration rules of varying orders. These are created as tensor products of 
            <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre1D"/> rules along each axis. Each quadrature is a singleton that can be accessed through this 
            class.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre2D.IntegrationPoints">
            <summary>
            The integration points are sorted based on an order strictly defined for each quadrature.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre3D">
            <summary>
            Contains the 3D Gauss-Legendre integration rules of varying orders. These are created as tensor products of 
            <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre1D"/> rules along each axis. Each quadrature is a singleton that can be accessed through this 
            class.
            Authors: Dimitris Tsapetis, Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.GaussLegendre3D.IntegrationPoints">
            <summary>
            The integration points are sorted based on an order strictly defined for each quadrature.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature1D">
            <summary>
            Collection of integration points that are generated by a traditional 1D quadrature rule, independent of the 
            element type. Thus these points can be cached as static fields of each enum class, so that accessing them is fast 
            and storing them is done only once for all elements. All integration points are with respect to a natural 
            coordinate system.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature1D.IntegrationPoints">
            <summary>
            The integrations points are sorted in increasing xi order. This order is strictly defined for each quadrature and 
            cannot change.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D">
            <summary>
            Collection of integration points that are generated by a traditional 2D quadrature rule, independent of the 
            element type. All integration points are with respect to a natural (element local) coordinate system.
            These integration points are stored as static fields of an enum class, so that accessing them is fast 
            and there is only one copy for all elements. The <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D"/> object and the collection of integration
            points it returns are both immutable.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints">
            <summary>
            The integration points are sorted based on an order strictly defined for each quadrature.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D">
            <summary>
            Collection of integration points that are generated by a traditional 3D quadrature rule, independent of the 
            element type. All integration points are with respect to a natural (element local) coordinate system.
            These integration points are stored as static fields of an enum class, so that accessing them is fast 
            and there is only one copy for all elements. The <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D"/> object and the collection of integration
            points it returns are both immutable.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D.IntegrationPoints">
            <summary>
            The integration points are sorted based on an order strictly defined for each quadrature.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.PyramidQuadrature">
            <summary>
            Enum class with the 3D integration rules for tetrahedra of varying orders. These are not tensor product of
            simple <see cref="!:GaussLegendre1D_old"/> rules. Quadrature rules were provided in https://www.code-aster.org/V2/doc/v11/fr/man_r/r3/r3.01.01.pdf
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.TetrahedronQuadrature">
            <summary>
            Enum class with the 2D integration rules for tetrahedra of varying orders. These are not tensor product of
            simple <see cref="!:GaussLegendre1D_old"/> rules. Quadrature rules were provided in https://www.code-aster.org/V2/doc/v11/en/man_r/r3/r3.01.01.pdf
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.TriangleQuadratureSymmetricGaussian">
            <summary>
            Enum class with the 2D integration rules for triangles of varying orders. These are not tensor product of 
            simple <see cref="!:GaussLegendre1D_old"/> rules. Instead the points are derived by symmetric Gaussian quadratures for
            triangles which are more efficient. 
            The theory is published in: "High degree efficient symmetrical Gaussian quadrature rules for the triangle", 
            D. A. Dunavant, 1985. It is also explained in http://math2.uncc.edu/~shaodeng/TEACHING/math5172/Lectures/Lect_15.PDF. The
            integration rules listed in the book: "Finite Element Procedures", K. J. Bathe, 2014 are a subset of the Dunavant rules
            (Gauss points are ordered differently), even though Bathe attributes them to G. R. Cowper.
            Note that in the integral: \iint_T f(xi, eta)*dxi*deta = \sum_{i=1}^N w_i * f(xi_i, eta_i), the factor 1/2 that is
            commonly seen in front of the sum in some sources, is incorporated into the weight factor here.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Integration.Quadratures.WedgeQuadrature">
            <summary>
            Enum class with the 2D integration rules for wedges of varying orders. These are not tensor product of
            simple <see cref="!:GaussLegendre1D_old"/> rules. Quadrature rules were provided in https://www.code-aster.org/V2/doc/default/fr/man_r/r3/r3.01.01.pdf
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Numerics.Integration.Quadratures.WedgeQuadrature.Points6">
            <summary>
            6-integration point quadrature for order 3 of axis x, and order 2 for both axis y and z.
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Numerics.Integration.Quadratures.WedgeQuadrature.Points8">
            <summary>
            8-integration point rule for order 3 for all axes.
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Numerics.Integration.Quadratures.WedgeQuadrature.Points21">
            <summary>
            8-integration point rule for order 3 for all axes.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D">
            <summary>
            Stores the shape functions, 1st order derivatives with respect to the global cartesian coordinates and the Jacobian
            of an interpolation, evaluated at a certain natural point of a finite element. These quantities are needed in many 
            places, thus passing an instance of this class is less verbose and error prone.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D.Jacobian">
            <summary>
            The inverse Jacobian matrix of the interpolation and its determinant.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D.ShapeFunctions">
            <summary>
            A vector that contains the shape functions in the same order as the nodes of the interpolation.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D.ShapeGradientsCartesian">
            <summary>
            A matrix that contains the 1st order shape function derivatives with respect to the global cartesian coordinate 
            system at the integration points defined by a given quadrature. Each row corresponds to the gradient of a single 
            shape function. Each column corresponds to the derivatives of all shape functions with respect to a single 
            coordinate.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D.ShapeGradientsNatural">
            <summary>
            A matrix that contains the 1st order shape function derivatives with respect to the natural coordinate 
            system at the integration points defined by a given quadrature. Each row corresponds to the gradient of a single 
            shape function. Each column corresponds to the derivatives of all shape functions with respect to a single 
            coordinate.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D">
            <summary>
            Stores the shape functions, 1st order derivatives with respect to the global cartesian coordinates and the Jacobian
            of an interpolation, evaluated at a certain natural point of a finite element. These quantities are needed in many 
            places, thus passing an instance of this class is less verbose and error prone.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D.Jacobian">
            <summary>
            The inverse Jacobian matrix of the interpolation and its determinant.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D.ShapeFunctions">
            <summary>
            A vector that contains the shape functions in the same order as the nodes of the interpolation.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D.ShapeGradientsCartesian">
            <summary>
            A matrix that contains the 1st order shape function derivatives with respect to the global cartesian coordinate 
            system at the integration points defined by a given quadrature. Each row corresponds to the gradient of a single 
            shape function. Each column corresponds to the derivatives of all shape functions with respect to a single 
            coordinate.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D.ShapeGradientsNatural">
            <summary>
            A matrix that contains the 1st order shape function derivatives with respect to the natural coordinate 
            system at the integration points defined by a given quadrature. Each row corresponds to the gradient of a single 
            shape function. Each column corresponds to the derivatives of all shape functions with respect to a single 
            coordinate.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2">
            <summary>
            Calculates extrapolations of scalar, vector and tensor fields from the integration points of 2-by-2 Gauss-Legendre 
            quadrature. This can be done at any point, but utility methods for directly outputting the extrapolated fields at the
            nodes of finite elements are also provided.
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2x2">
            <summary>
            Calculates extrapolations of scalar , vector and tensor fields from the integration points of 2-by-2-by-2 Gauss-Legendre
            quadrature. this can be done at any point , but utility methods for directly outputting the extrapolated fields at the
            nodes of finite elements are also provided.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2x2.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre2x2x2"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre3x3">
            <summary>
            Calculates extrapolations of scalar, vector and tensor fields from the integration points of 3-by-3 Gauss-Legendre 
            quadrature. This can be done at any point, but utility methods for directly outputting the extrapolated fields at the
            nodes of finite elements are also provided.
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre3x3.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussLegendre3x3"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point" -->
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.Quadrature">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular1Point.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular3Points">
            <summary>
            Calculates extrapolations of scalar, vector and tensor fields from the integration points of 
            <see cref="!:TriangleSymmetricGaussianQuadrature.Order2Points3"/>. This can be done at any point, but utility methods for  
            directly outputting the extrapolated fields at the nodes of finite elements are also provided.
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular3Points.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.ExtrapolationGaussTriangular3Points"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase">
            <summary>
            Basic implementation of <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D"/>.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.cachedExtrapolationFunctionsAtNodes">
            <summary>
            Each <see cref="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D"/> is mapped to a 2D array that contains the values of the 
            extrapolation functions calculated at the nodes of the finite element using that interpolation. Each row corresponds
            to a different node. Each columns corresponds to a different extrapolation function.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.Quadrature">
            <summary>
            The integration rule which defines the integration points used for extrapolating values and defining an auxiliary 
            coordinate system.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation2DBase.EvaluateExtrapolationFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates the functions used for extrapolating quantities from the integration points to a given point, at the 
            given point.
            </summary>
            <param name="point">The coordinates of the point where the extrapolation functions will be calculated, in the 
                natural (element local) system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase">
            <summary>
            Basic implementation of <see cref="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D"/>.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.cachedExtrapolationFunctionsAtNodes">
            <summary>
            Each <see cref="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D"/> is mapped to a 2D array that contains the values of the 
            extrapolation functions calculated at the nodes of the finite element using that interpolation. Each row corresponds
            to a different node. Each columns corresponds to a different extrapolation function.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature">
            <summary>
            The integration rule which defines the integration points used for extrapolating values and defining an auxiliary 
            coordinate system.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a scalar quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="scalarAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="naturalPoint">The point where the scalar will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a scalar quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="scalarsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a tensor quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="naturalPoint">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a tensor quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a vector quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="vectorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="naturalPoint">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a vector quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="vectorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.GaussPointExtrapolation3DBase.EvaluateExtrapolationFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates the functions used for extrapolating quantities from the integration points to a given point, at the 
            given point.
            </summary>
            <param name="naturalPoint">The coordinates of the point where the extrapolation functions will be calculated, in the 
                natural (element local) system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D">
            <summary>
            Calculates extrapolations of scalar, vector and tensor fields from the integration points of a quadrature (integration 
            rule). This can be done at any point, but utility methods for directly outputting the extrapolated fields at the nodes
            of finite elements are also provided.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature">
            <summary>
            The integration rule which defines the integration points used for extrapolating values and defining an auxiliary 
            coordinate system.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a scalar quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="scalarsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="point">The point where the scalar will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            Calculates a scalar quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="scalarsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a tensor quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="point">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a tensor quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="point">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            Calculates a tensor quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.DataStructures.Tensor2D},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            Calculates a tensor quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a vector quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="vectorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="point">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D)">
            <summary>
            Calculates a vector quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="vectorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation2D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D">
            <summary>
            Calculates extrapolations of scalar, vector and tensor fields from the integration points of a quadrature (integration 
            rule). This can be done for any point, but utility methods for directly outputting the extrapolated fields at the nodes
            of finite elements are also provided.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature">
            <summary>
            The integration rule which defines the integration points used for extrapolating values and defining an auxiliary 
            coordinate system.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateScalarFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a scalar quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="scalarsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="point">The point where the scalar will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateScalarFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a scalar quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="scalarAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateTensorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a tensor quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="naturalPoint">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateTensorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a tensor quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="tensorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateVectorFromGaussPoints(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Calculates a vector quantity at a given point by extrapolating (or interpolating) its known values at 
            the integration points.
            </summary>
            <param name="vectorAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="naturalPoint">The point where the tensor will be computed. Its coordinates are expressed in the natural
                (element local) system, instead of the coordinate system defined by the integration points.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.ExtrapolateVectorFromGaussPointsToNodes(System.Collections.Generic.IReadOnlyList{System.Double[]},MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D)">
            <summary>
            Calculates a vector quantity at the nodes of a finite element by extrapolating its known values at the integration 
            points.
            </summary>
            <param name="vectorsAtGaussPoints">Their order must be the same as the order of integration points defined by 
                <see cref="P:MGroup.MSolve.Numerics.Interpolation.GaussPointExtrapolation.IGaussPointExtrapolation3D.Quadrature"/>.</param>
            <param name="interpolation">Defines the natural coordinates of the finite element's nodes.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D">
            <summary>
            Interpolation (or shape or basis) functions used by isoparametric finite elements. Instances are able to compute the 
            values of the shape functions, their derivatives, the Jacobian of the matrix, etc.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CellType">
            <summary>
            The shape of a cell. Useful for interacting with other modules and software.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.NumFunctions">
            <summary>
            The number of shape functions that define this interpolation.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            Checks the number and possibly the order of an element's nodes.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the shape functions, the 1st order derivatives with respect to the global cartesian coordinate system and 
            the jacobian at a given natural point.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            Evaluate the shape functions, the 1st order derivatives with respect to the global cartesian coordinate system and
            the jacobian at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of 
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/> when the integration points of an element are
            the same across multiple elements or multiple iterations of a non linear or dynamic analysis (in the latter cases
            we could also cache the <see cref="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D"/> at the integration points of each element). 
            The <see cref="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation2D"/>s per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints"/>.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="quadrature">The integration rule that defines integration points where shape functions and derivatives  
                are calculated. The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D"/> are always the 
                same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the shape functions at a given natural point and returns them in a vector in the same order as the nodes
            of the interpolation.
            </summary>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            Evaluate the shape functions at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of 
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/> when the integration points of an element are the same across 
            multiple elements or multiple iterations of a non linear or dynamic analysis.
            The shape functions vectors per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints"/>. Each vector contains the
            shape functions in the same order as the nodes of the interpolation.
            </summary>
            <param name="quadrature">The integration rule that defines integration points where shape functions are calculated. 
                The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D"/> are always the same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the 1st order shape function derivatives with respect to the natural coordinate system 
            at a given natural point. 
            Each row of the returned matrix corresponds to the gradient of a single shape function. Each column corresponds to 
            the derivatives of all shape functions with respect to a single coordinate.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            Evaluate the 1st order shape function derivatives with respect to the natural coordinate system 
            at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of 
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>, when the integration points of an element 
            are the same across multiple elements or multiple iterations of a non linear or dynamic analysis (in the latter 
            cases we could also cache the cartesian gradients at the integration points of each element). 
            The shape gradients matrices per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints"/>. Each row of a matrix  
            corresponds to the gradient of a single shape function. Each column corresponds to the derivatives of all shape
            functions with respect to a single coordinate.
            </summary>
            <param name="quadrature">The integration rule that defines integration points where shape function derivatives are 
                calculated. The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D"/> are always the same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Transforms the coordinates from the natural (element local) coordinate system to the the global
            coordinate system of a point that is internal to the finite element.
            </summary>
            <param name="nodes">The coordinates of the finite element's nodes in the global cartesian system.</param>
            <param name="naturalPoint">The coordinates in the natural system of a point that is internal to the finite 
                element.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D">
            <summary>
            Interpolation (or shape or basis) functions used by isoparametric finite elements. Instances are able to compute the 
            values of the shape functions, their derivatives, the Jacobian of the matrix, etc.
            Authors: Dimitris Tsapetis, Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.CellType">
            <summary>
            The shape of a cell. Useful for interacting with other modules and software.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.NumFunctions">
            <summary>
            The number of shape functions that define this interpolation.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            Checks the number and possibly the order of an element's nodes.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the shape functions, the 1st order derivatives with respect to the global cartesian coordinate system 
            and the jacobian at a given natural point.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            Evaluate the shape functions, the 1st order derivatives with respect to the global cartesian coordinate system and
            the jacobian at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of when the integration points of an 
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>
            element are the same across multiple elements or multiple iterations of a non linear or dynamic analysis (in the 
            latter cases we could also cache the <see cref="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D"/> at the integration points of each element).
            The <see cref="T:MGroup.MSolve.Numerics.Interpolation.EvalInterpolation3D"/>s per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D.IntegrationPoints"/>.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="quadrature">The integration rule that defines integration points where shape functions and derivatives  
                are calculated. The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D"/> are always the 
                same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the shape functions at a given natural point and returns them in a vector in the same order as the nodes
            of the interpolation.
            </summary>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            Evaluate the shape functions at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of 
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/> when the integration points of an element are the same across 
            multiple elements or multiple iterations of a non linear or dynamic analysis.
            The shape functions vectors per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints"/>. Each vector contains the
            shape functions in the same order as the nodes of the interpolation.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="quadrature">The integration rule that defines integration points where shape functions are calculated. 
                The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D"/> are always the same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Evaluate the 1st order shape function derivatives with respect to the natural coordinate system 
            at a given natural point.
            Each row of the returned matrix corresponds to the gradient of a single shape function. Each column corresponds to 
            the derivatives of all shape functions with respect to a single coordinate.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="naturalPoint">The coordinates of the point in the natural (element local) coordinate system of the 
                element.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            Evaluate the 1st order shape function derivatives with respect to the natural coordinate system 
            at the integration points defined by a given quadrature. 
            This method caches all possible quantities from previous calls. Use it instead of  
            <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/> when the integration points of an element are the same
            across multiple elements or multiple iterations of a non linear or dynamic analysis (in the latter cases we could
            also cache the cartesian gradients at the integration points of each element).
            The shape gradients matrices per integration point are returned in the same order as the integration 
            points in <paramref name="quadrature"/>.<see cref="P:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D.IntegrationPoints"/>. Each row of a matrix  
            corresponds to the gradient of a single shape function. Each column corresponds to the derivatives of all shape
            functions with respect to a single coordinate.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <param name="quadrature">The integration rule that defines integration points where shape function derivatives are 
                calculated. The integration points of this instance of <see cref="T:MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D"/> are always the same.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            Transforms the coordinates from the natural (element local) coordinate system to the the global
            coordinate system of a point that is internal to the finite element.
            </summary>
            <param name="nodes">The coordinates of the finite element's nodes in the global cartesian system.</param>
            <param name="naturalPoint">The coordinates in the natural system of a point that is internal to the finite 
                element.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20">
            <summary>
            Isoparametric interpolation of a hexahedral finite element with 8 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa20.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27">
            <summary>
            Isoparametric interpolation of a hexahedral finite element with 27 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27.NodalNaturalCoordinates">
            <summary>
            The coordinate of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa27.EvaluateAt(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates Hexa27 shape functions according to <see cref="!:https://www.code-aster.org/V2/doc/v13/en/man_r/r3/r3.01.01.pdf">this</see>
            </summary>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="zeta"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationHexa8.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13">
            <summary>
            Isoparametric interpolation of a pyramid finite element with 13 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra13.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14">
            <summary>
            Isoparamateric interpolation of a pyramid finite element with 14 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra14.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5">
            <summary>
            Isoparametric interpolation of pyramid finite element with 5 nodes. Linear shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationPyra5.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4">
            <summary>
            Isoparametric interpolation of a quadrilateral finite element with 4 nodes. Linear shape functions.
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="!:IIsoparametricInterpolation2D.CheckElementNodes(IReadOnlyList&lt;Node&gt;)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad4.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8">
            <summary>
            Isoparametric interpolation of a quadrilateral finite element with 8 nodes. Quadratic shape functions. 
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad8.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9">
            <summary>
            Isoparametric interpolation of a quadrilateral finite element with 9 nodes. Quadratic shape functions. 
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationQuad9.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationShell8.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationShell8Cohesive.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10">
            <summary>
            Isoparametric interpolation of a tetrahedral finite element with 10 nodes. Quadratic shape function.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet10.EvaluateAt(System.Double,System.Double,System.Double)">
            <summary>
            Returns the shape functions a tetrahedral quadratic element evaluated on a single point.
            Implementation is based on <see cref="!:https://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch10.d/AFEM.Ch10.pdf">Carlos Felippa - Introduction to Finite Element Methods</see>
            </summary>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="zeta"></param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4">
            <summary>
            Isoparametric interpolation of a tetrahedral finite element with 4 nodes. Linear shape functions.
            Implements sigleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTet4.EvaluateAt(System.Double,System.Double,System.Double)">
            <summary>
            Returns the shape functions a tetrahedral linear element evaluated on a single point.
            Implementation is based on <see cref="!:https://www.colorado.edu/engineering/CAS/courses.d/AFEM.d/AFEM.Ch09.d/AFEM.Ch09.pdf">Carlos Felippa - Introduction to Finite Element Methods</see>
            </summary>
            <param name="xi"></param>
            <param name="eta"></param>
            <param name="zeta"></param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3">
            <summary>
            Isoparametric interpolation of a triangular finite element with 3 nodes. Linear shape functions. 
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="!:IIsoparametricInterpolation2D.CheckElementNodes(IReadOnlyList&lt;Node&gt;)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTri3.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6">
            <summary>
            Isoparametric interpolation of a triangular finite element with 6 nodes. Quadratic shape functions.
            The shape function computations are presented in Papadrakakis book (2001 print) pages 230-232.
            Implements Singleton pattern. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTri6.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTruss1D">
            <summary>
            Isoparametric interpolation of a quadrilateral finite element with 4 nodes. Linear shape functions.
            Implements Singleton pattern.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTruss1D.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order of these
            nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationTruss1D.UniqueInstance">
            <summary>
            Get the unique <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationTruss1D"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationTruss1D.EvaluateAt(System.Double)">
            <summary>
            The inverse mapping of this interpolation, namely from global cartesian to natural (element local) coordinate system.
            </summary>
            <param name="nodes">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationUtilities">
            <summary>
            Authors: Serafeim Bakalakos, Dimitris Tsapetis
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15">
            <summary>
            Isoparamteric interpolation of a wedge finite element with 15 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge15.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18">
            <summary>
            Isoparametric interpolation of a wedge with 18 nodes. Quadratic shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge18.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6">
            <summary>
            Isoparametric interpolation of a wedge finite element with 6 nodes. Linear shape functions.
            Implements singleton pattern.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6.NodalNaturalCoordinates">
            <summary>
            The coordinates of the finite element's nodes in the natural (element local) coordinate system. The order
            of these nodes matches the order of the shape functions and is always the same for each element.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6.UniqueInstance">
            <summary>
            Get the unique instance <see cref="T:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6"/> object for the whole program. Thread safe.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CheckElementNodes(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.InterpolationWedge6.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            The reverse mapping for this interpolation, namely from global cartesian coordinates to natural (element local) coordinate system.
            </summary>
            <param name="node">The nodes of the finite element in the global cartesian coordinate system.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Inverse.IInverseInterpolation2D">
            <summary>
            Inverse mapping of an isoparametric interpolation, namely from global cartesian to natural (element local) coordinate 
            system. In general these are computationally inefficient and inexact, beacuse they use iterative algorithms, with 
            the exception of linear interpolations, for which there exist analytic formulas.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Inverse.IInverseInterpolation2D.TransformPointCartesianToNatural(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)">
            <summary>
            Finds the coordinates in the natural (element local) system of a point known in the global cartesian system.
            </summary>
            <param name="point">The coordinates of the point in the global cartesian system. The point must be internal to the 
                element for the method to work, unless otherwise stated by the implementing class.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Inverse.IInverseInterpolation3D">
            <summary>
            Inverse mapping of an isoparametric interpolation, namely from global cartesian to natural (element local) coordinate 
            system. In general these are computationally inefficient and inexact, beacuse they use iterative algorithms, with 
            the exception of linear interpolations, for which there exist analytic formulas.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Inverse.IInverseInterpolation3D.TransformPointCartesianToNatural(MGroup.MSolve.Geometry.Coordinates.CartesianPoint)">
            <summary>
            Finds the coordinates in the natural (element local) system of a point known in the global cartesian system.
            </summary>
            <param name="point">The coordinates of the point in the global cartesian system. The point must be internal to the 
                element for the method to work, unless otherwise stated by the implementing class.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Inverse.InverseInterpolationHexa8">
            <summary>
            Inverse mapping of the isoparametric interpolation of a hexahedral finite element with 8 nodes. Since the original
            mapping is linear, there are analytic formulas, which are presented in 
            "The inverse mapping and distortion measures for 8-node hexahedral isoparametric elements", K. -Y. YuanY. -S. HuangH. -T. YangT. H. H. Pian, 1994
            https://link.springer.com/article/10.1007/BF00350284
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Inverse.InverseInterpolationQuad4">
            <summary>
            Inverse mapping of the isoparametric interpolation of a quadrilateral finite element with 4 nodes. Since the original 
            mapping is linear, there are analytic formulas, which are presented in
            "An inverse transformation for quadrilateral isoparametric elements: Analysis and application", Chongyu Hua, 1990 
            https://www.sciencedirect.com/science/article/pii/0168874X90900072 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Inverse.InverseInterpolationQuad4.CycleCounterClockwise(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            Reorders the nodes such that the 1st one becomes the 2nd, the 2nd one becomes the 3rd, etc.
            </summary>
            <param name="nodes"></param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Inverse.InverseInterpolationQuad4.SolveQuadraticEquation(System.Double,System.Double,System.Double)">
            <summary>
            Solves a * x^2 + b * x + c = 0
            </summary>
            <param name="quadCoeff">Coefficient of quadratic term</param>
            <param name="linCoeff">Coefficient of linear term</param>
            <param name="constCoeff">Coeffecient of constant term</param>
            <returns>The solutions in an array of size 0, 1 or 2</returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Inverse.InverseInterpolationTri3">
            <summary>
            Inverse mapping of the isoparametric interpolation of a triangular finite element with 3 nodes. Since the original 
            mapping is linear, there are analytic formulas.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase">
            <summary>
            Basic implementation of <see cref="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D"/>.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.CellType">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CellType"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.NumFunctions">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.NumFunctions"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.NodalNaturalCoordinates">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.NodalNaturalCoordinates"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)" -->
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature2D)"/>.
            </summary>
            <param name="quadrature"></param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation2D.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateAt(System.Double,System.Double)">
            <summary>
            Evaluate shape function at a given point expressed in the natural coordinate system. Each entry corresponds to a
            different shape function.
            </summary>
            <param name="xi">The coordinate of the point along local axis Xi.</param>
            <param name="eta">The coordinate of the point along local axis Eta.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation2DBase.EvaluateGradientsAt(System.Double,System.Double)">
            <summary>
            Evaluate derivatives of shape functions with respect to natural coordinates at a given point expressed in the 
            natural coordinate system. Each row corresponds to a different shape function, column 0 corresponds to derivatives
            with respect to Xi coordinate and column 1 corresponds to derivatives with respect to Eta coordinate.
            </summary>
            <param name="xi">The coordinate of the point along local axis Xi.</param>
            <param name="eta">The coordinate of the point along local axis Eta.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase">
            <summary>
            Basic implementation of <see cref="T:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D"/>
            Authors: Dimitris Tsapetis, Serafeim Bakalakos
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.CellType">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.CellType"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.NumFunctions">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.NumFunctions"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.NodalNaturalCoordinates">
            <summary>
            See <see cref="P:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.NodalNaturalCoordinates"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.CreateInverseMappingFor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode})"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateAllAt(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateAllAtGaussPoints(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)"/>
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateFunctionsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateFunctionsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateNaturalGradientsAt(MGroup.MSolve.Geometry.Coordinates.NaturalPoint)" -->
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.EvaluateNaturalGradientsAtGaussPoints(MGroup.MSolve.Numerics.Integration.Quadratures.IQuadrature3D)"/>.
            </summary>
            <param name="quadrature"></param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)">
            <summary>
            See <see cref="M:MGroup.MSolve.Numerics.Interpolation.IIsoparametricInterpolation3D.TransformNaturalToCartesian(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.MSolve.Geometry.Coordinates.NaturalPoint)"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateAt(System.Double,System.Double,System.Double)">
            <summary>
            Evaluate shape function at a given point expressed in the natural coordinate system. Each entry corresponds to a
            different shape function.
            </summary>
            <param name="xi">The coordinate of the point along local axis Xi.</param>
            <param name="eta">The coordinate of the point along local axis Eta.</param>
            <param name="zeta">The coordinate of the point along local axis Zeta.</param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.IsoparametricInterpolation3DBase.EvaluateGradientsAt(System.Double,System.Double,System.Double)">
            <summary>
            Evaluate derivatives of shape functions with respect to natural coordinates at a given point expressed in the 
            natural coordinate system. Each row corresponds to a different shape function, column 0 corresponds to derivatives
            with respect to Xi coordinate, column 1 corresponds to derivatives with respect to Eta coordinate, etc.
            </summary>
            <param name="xi">The coordinate of the point along local axis Xi.</param>
            <param name="eta">The coordinate of the point along local axis Eta.</param>
            <param name="zeta">The coordinate of the point along local axis Zeta.</param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D">
            <summary>
            This class encapsulates the determinant and inverse of the Jacobian matrix for a 2D isoparametric mapping.
            Let f be a mapping: x \in R^2 -> f(x) \in R^2. The Jacobian matrix of the mapping is (in numerator layout): 
            J = [df_1/dx_1 df_1/dx_2; df_2/dx_1 df_2/dx_2]. 
            Note that some sources call the transpose of this matrix as J. In FEM we are usually interested in the determinant and
            inverse of the Jacobian matrix. 
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.#ctor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.LinearAlgebra.Matrices.Matrix,System.Double)">
            <summary>
            The caller (usually the interpolation class) assumes responsibility for matching the nodes to the shape function 
            derivatives. The static DeterminantTolerance variable contains the default derivative tolerance under which determinant is supposed to be zero.
            </summary>
            <param name="nodes">The nodes used for the interpolation.</param>
            <param name="naturalDerivatives">The shape function derivatives at a specific integration point.</param>
            <param name="tolerance">The value under which the jacobian determinant is considered unaccaptable.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.#ctor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.LinearAlgebra.Matrices.Matrix)">
            <summary>
            The caller (usually the interpolation class) assumes responsibility for matching the nodes to the shape function 
            derivatives.
            </summary>
            <param name="nodes">The nodes used for the interpolation.</param>
            <param name="naturalDerivatives">The shape function derivatives at a specific integration point.</param>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.DirectDeterminant">
            <summary>
            The determinant of the direct Jacobian matrix <see cref="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.DirectMatrix"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.DirectMatrix">
            <summary>
            The Jacobian matrix of the direct mapping. Numerator layout is used:
            J = [df_1/dx_1 df_1/dx_2; df_2/dx_1 df_2/dx_2].
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.InverseMatrix">
            <summary>
            The inverse of the Jacobian matrix. Numerator layout used is used:
            inv(J) = [dx_1/df_1 dx_1/df_2 ; dx_2/df_1 dx_2/df_2]
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.TransformNaturalDerivativesToCartesian(MGroup.LinearAlgebra.Matrices.Matrix)">
            <summary>
            Transforms the gradient of a vector-valued function from the natural to the global cartesian coordinate system.
            </summary>
            <param name="naturalGradient">The gradient of a vector-valued function in the natural coordinate system. Each row 
                corresponds to the gradient of a single component of the vector function. Each column corresponds to the 
                derivatives of all components with respect to a single coordinate.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian2D.TransformNaturalDerivativesToCartesian(System.Double[])">
            <summary>
            Transforms the gradient of a scalar-valued function from the natural to the global cartesian coordinate system.
            </summary>
            <param name="naturalGradient">The gradient of a scalar-valued function in the natural coordinate system. Each entry 
                corresponds to the derivative with respect to a single coordinate.</param>
        </member>
        <member name="T:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D">
            <summary>
            This class encapsulates the determinant and inverse of the Jacobian matrix for a 3D isoparametric mapping.
            Let f be a mapping: x \in R^3 -> f(x) \in R^3. The Jacobian matrix of the mapping is (in numerator layout): 
            J = [df_1/dx_1 df_1/dx_2 df_1/dx_3; df_2/dx_1 df_2/dx_2 df_2/dx_3; df_3/dx_1 df_3/dx_2 df_3/dx_3]. 
            Note that some sources call the transpose of this matrix as J. In FEM we are usually interested in the determinant and 
            inverse of the Jacobian matrix.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.#ctor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.LinearAlgebra.Matrices.Matrix,System.Double)">
            <summary>
            The caller (usually the interpolation class) assumes responsibility for matching the nodes to the shape function 
            derivatives.
            </summary>
            <param name="nodes">The nodes used for the interpolation.</param>
            <param name="naturalDerivatives">The shape function derivatives at a specific integration point.</param>
            <param name="tolerance">The value under which the jacobian determinant is considered unaccaptable.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.#ctor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.LinearAlgebra.Matrices.Matrix)">
            <summary>
            The caller (usually the interpolation class) assumes responsibility for matching the nodes to the shape function 
            derivatives. The static DeterminantTolerance variable contains the default derivative tolerance under which determinant is supposed to be zero.
            </summary>
            <param name="nodes">The nodes used for the interpolation.</param>
            <param name="naturalDerivatives">The shape function derivatives at a specific integration point.</param>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.DirectDeterminant">
            <summary>
            The determinant of the direct Jacobian matrix <see cref="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.DirectMatrix"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.DirectMatrix">
            <summary>
            The Jacobian matrix of the direct mapping. Numerator layout is used:
            J = [df_1/dx_1 df_1/dx_2 df_1/dx_3; df_2/dx_1 df_2/dx_2 df_2/dx_3; df_3/dx_1 df_3/dx_2 df_3/dx_3].
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.InverseMatrix">
            <summary>
            The inverse of the Jacobian matrix. Numerator layout used is used:
            inv(J) = [dx_1/df_1 dx_1/df_2 dx_1/df_3; dx_2/df_1 dx_2/df_2 dx_2/df_3; dx_3/df_1 dx_3/df_2 dx_3/df_3]
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.TransformNaturalDerivativesToCartesian(MGroup.LinearAlgebra.Matrices.Matrix)">
            <summary>
            Transforms the gradient of a vector-valued function from the natural to the global cartesian coordinate system.
            </summary>
            <param name="naturalGradient">The gradient of a vector-valued function in the natural coordinate system. Each row 
                corresponds to the gradient of a single component of the vector function. Each column corresponds to the 
                derivatives of all components with respect to a single coordinate.</param>
        </member>
        <member name="M:MGroup.MSolve.Numerics.Interpolation.Jacobians.IsoparametricJacobian3D.TransformNaturalDerivativesToCartesian(System.Double[])">
            <summary>
            Transforms the gradient of a scalar-valued function from the natural to the global cartesian coordinate system.
            </summary>
            <param name="naturalGradient">The gradient of a scalar-valued function in the natural coordinate system. Each entry 
                corresponds to the derivative with respect to a single coordinate.</param>
        </member>
        <member name="T:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2">
            <summary>
            This class encapsulates the determinant and inverse of the Jacobian matrix for a 3D isoparametric mapping.
            Let f be a mapping: x \in R^3 -> f(x) \in R^3. The Jacobian matrix of the mapping is (in numerator layout): 
            J = [df_1/dx_1 df_1/dx_2 df_1/dx_3; df_2/dx_1 df_2/dx_2 df_2/dx_3; df_3/dx_1 df_3/dx_2 df_3/dx_3]. 
            Note that some sources call the transpose of this matrix as J. In FEM we are usually interested in the determinant and 
            inverse of the Jacobian matrix.
            Authors: Dimitris Tsapetis
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.#ctor(System.Collections.Generic.IReadOnlyList{MGroup.MSolve.Discretization.Entities.INode},MGroup.LinearAlgebra.Matrices.Matrix)">
            <summary>
            The caller (usually the interpolation class) assumes responsibility for matching the nodes to the shape function 
            derivatives.
            </summary>
            <param name="nodes">The nodes used for the interpolation.</param>
            <param name="naturalCoordinates">The shape function derivatives at a specific integration point.</param>
        </member>
        <member name="F:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.DirectDeterminant">
            <summary>
            The determinant of the direct Jacobian matrix <see cref="P:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.DirectMatrix"/>.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.DirectMatrix">
            <summary>
            The Jacobian matrix of the direct mapping. Numerator layout is used:
            J = [df_1/dx_1 df_1/dx_2 df_1/dx_3; df_2/dx_1 df_2/dx_2 df_2/dx_3; df_3/dx_1 df_3/dx_2 df_3/dx_3].
            </summary>
        </member>
        <member name="F:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.InverseMatrix">
            <summary>
            The inverse of the Jacobian matrix. Numerator layout used is used:
            inv(J) = [dx_1/df_1 dx_1/df_2 dx_1/df_3; dx_2/df_1 dx_2/df_2 dx_2/df_3; dx_3/df_1 dx_3/df_2 dx_3/df_3]
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Core.Numerics.Interpolation.Jacobians.IsoparametricJacobian3Dv2.TransformNaturalDerivativesToCartesian(System.Double[])">
            <summary>
            Transforms the gradient of a scalar-valued function from the natural to the global cartesian coordinate system.
            </summary>
            <param name="naturalGradient">The gradient of a scalar-valued function in the natural coordinate system. Each entry 
                corresponds to the derivative with respect to a single coordinate.</param>
        </member>
        <member name="T:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModel">
            <summary>
            This component is responsible for the linear algebra representation, namely global vectors and matrices, of the physical 
            model. It is also responsible for conversions between the physical and algebraic representations.  
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModel.ReorderDofs">
            <summary>
            Same effect as <see cref="M:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModel.OrderDofs"/>, but avoids repeating dof ordering computations from previous analysis 
            iterations, as much as possible.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModelObserver.HandleDofOrderWasModified">
            <summary>
            It will be called after the dof order is modified by calls to <see cref="M:MGroup.MSolve.Solution.AlgebraicModel.IAlgebraicModel.OrderDofs"/>.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IElementIterator.DoPerElement``1(System.Action{``0})">
            <summary>
            Performs <paramref name="elementOperation"/> on all elements/>.
            </summary>
            <param name="elementOperation"></param>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IElementIterator.ReduceSumPerElement``1(System.Int32,System.Func{System.Int32,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Double[]})">
            <summary>
            Performs <paramref name="elementOperation"/> on all elements accessed by calling <paramref name="accessElements"/>.
            The resulting element vectors are reduced into a single result with <paramref name="numReducedValues"/> entries. 
            </summary>
            <param name="numReducedValues"></param>
            <param name="accessElements"></param>
            <param name="elementOperation"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IElementIterator.ReduceSumPerElement``1(System.Int32,System.Func{System.Int32,System.Collections.Generic.IEnumerable{``0}},System.Predicate{``0},System.Func{``0,System.Double[]})">
            <summary>
            Performs <paramref name="elementOperation"/> on all elements accessed by calling <paramref name="accessElements"/>,
            which also satisfy <paramref name="isActiveElement"/>.
            The resulting element vectors are reduced into a single result with <paramref name="numReducedValues"/> entries. 
            </summary>
            <param name="numReducedValues"></param>
            <param name="accessElements"></param>
            <param name="isActiveElement"></param>
            <param name="elementOperation"></param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Solution.AlgebraicModel.IGlobalMatrixAssembler">
            <summary>
            Builds the matrix of the linear system that will be solved.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IGlobalMatrixAssembler.BuildGlobalMatrix(MGroup.MSolve.Discretization.Providers.IElementMatrixProvider)">
            <summary>
            Builds the linear system matrix that corresponds to the free (unconstrained) freedom degrees.
            </summary>
            <param name="elementMatrixProvider">
            Determines the matrix calculated for each element (e.g. stiffness, mass, etc.)
            </param>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IGlobalMatrixAssembler.RebuildGlobalMatrixPartially(MGroup.MSolve.Solution.LinearSystem.IGlobalMatrix,System.Func{System.Int32,System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.IElementType}},MGroup.MSolve.Discretization.Providers.IElementMatrixProvider,MGroup.MSolve.Solution.AlgebraicModel.IElementMatrixPredicate)">
            <summary>
            Rebuilds the minimum necessary portions of the linear system matrix, depending on if 
            <see cref="!:IElementMatrixPredicate.MustBuildMatrixForElement(IElement)"/> of <paramref name="predicate"/>
            is satisfied for one or more elements. Even if <paramref name="predicate"/> is not satisfied for an element,
            its matrix may still be rebuilt, due to the behavior of neighboring elements. 
            For all elements that had their matrix rebuilt, 
            <see cref="!:IElementMatrixPredicate.ProcessElementAfterBuildingMatrix(IElement)"/>
            will be called afterwards. 
            For all elements that did not have their matrix rebuilt, 
            <see cref="!:IElementMatrixPredicate.ProcessElementAfterNotBuildingMatrix(IElement)"/> will be called 
            afterwards. 
            </summary>
            <param name="accessElements"></param>
            <param name="elementMatrixProvider"></param>
            <param name="predicate"></param>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IGlobalMatrixAssembler.RebuildGlobalMatrixPartially(MGroup.MSolve.Solution.LinearSystem.IGlobalMatrix,System.Func{System.Int32,System.Collections.Generic.IEnumerable{MGroup.MSolve.Discretization.IElementType}},MGroup.MSolve.Discretization.Providers.IElementMatrixProvider)">
            <summary>
            Builds and returns the linear system matrix that corresponds to the free (unconstrained) freedom degrees. Reuses 
            portions of <paramref name="previousMatrix"/> that have not changed due to partial changes in free dofs. 
            </summary>
            <param name="previousMatrix">
            A matrix that corresponds to different dofs, but parts of it can be reused. Will not be modified.
            </param>
            <param name="accessElements"></param>
            <param name="elementMatrixProvider"></param>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IVectorValueExtractor.ExtractElementVector(MGroup.MSolve.Solution.LinearSystem.IGlobalVector,MGroup.MSolve.Discretization.IElementType)">
            <summary>
            If the requested <paramref name="element"/> has dofs that are not included in <paramref name="vector"/>,
            then the corresponding entries of the returned vector will be 0.
            </summary>
            <param name="vector"></param>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:MGroup.MSolve.Solution.AlgebraicModel.IVectorValueExtractor.ExtractSingleValue(MGroup.MSolve.Solution.LinearSystem.IGlobalVector,MGroup.MSolve.Discretization.Entities.INode,MGroup.MSolve.Discretization.Dofs.IDofType)">
            <summary>
            If the requested (<paramref name="node"/>, <paramref name="dof"/>) pair is not a free dof or otherwise not included 
            in <paramref name="vector"/>, then <see cref="T:System.Collections.Generic.KeyNotFoundException"/> will be thrown.
            </summary>
            <param name="vector"></param>
            <param name="node"></param>
            <param name="dof"></param>
            <returns></returns>
        </member>
        <member name="T:MGroup.MSolve.Solution.ISolver">
            <summary>
            Helps translate the physical model into a linear system and then solves the latter. 
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Solution.ISolver.Logger">
            <summary>
            Logs information, such as linear system size, the time required for various solver tasks, etc.
            </summary>
        </member>
        <member name="P:MGroup.MSolve.Solution.ISolver.Name">
            <summary>
            The name of the solver for logging purposes.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.ISolver.Initialize">
            <summary>
            Initializes the state of this <see cref="T:MGroup.MSolve.Solution.ISolver"/> instance. This needs to be called only once, since it  
            could potentially perform actions that must not be repeated or are too expensive.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.ISolver.PreventFromOverwrittingSystemMatrices">
            <summary>
            Notifies this <see cref="T:MGroup.MSolve.Solution.ISolver"/> that it cannot overwrite the data of <see cref="P:MGroup.MSolve.Solution.LinearSystem.IGlobalLinearSystem.Matrix"/>.
            Some solvers would otherwise overwrite the matrices (e.g. with the factorization) to avoid using extra memory.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.ISolver.Solve">
            <summary>
            Solves the linear systems.
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.ISolverLogger.LogTaskDuration(System.String,System.Int64)">
            <summary>
            Adds the duration of the selected task to the duration of the same task during the current analysis step.
            </summary>
            <param name="task"></param>
            <param name="duration"></param>
        </member>
        <member name="M:MGroup.MSolve.Solution.ISolverLogger.IncrementAnalysisStep">
            <summary>
            Each iteration is defined by the solution phase of ISolver. Dof ordering and matrix assembly may also be included, 
            but they are not necessarily repeated in all analyses. Thus call it at the end of the Solve() method.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Solution.LinearSystem.IGlobalLinearSystem">
            <summary>
            A system of linear equations. It consists of a square matrix, a right hand side vector and a solution (or left 
            hand side) vector. In general objects implementing IAnalyzer determine the matrix and right hand side vector,  
            while objects implementing ISolver calculate the solution vector.
            </summary>
        </member>
        <member name="T:MGroup.MSolve.Solution.LinearSystem.ILinearSystemObserver">
            <summary>
            Objects implementing this interface will be notifying when the matrix of the linear system is modified.
            Authors: Serafeim Bakalakos
            </summary>
        </member>
        <member name="M:MGroup.MSolve.Solution.LinearSystem.ILinearSystemObserver.HandleMatrixWillBeSet">
            <summary>
            It will be called before setting <see cref="P:MGroup.MSolve.Solution.LinearSystem.IGlobalLinearSystem.Matrix"/>.
            </summary>
        </member>
    </members>
</doc>
